<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Wild Fox: Fixed Camera View</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #1a1a2e; 
            font-family: 'Noto Sans KR', sans-serif; 
            user-select: none; cursor: none;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .top-hud { position: absolute; top: 30px; left: 50%; transform: translateX(-50%); text-align: center; width: 60%; }
        h1 { margin: 0; font-family: 'Orbitron', sans-serif; font-size: 2.5rem; color: #fff; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 15px rgba(0, 255, 255, 0.9); }
        .size-bar-container { margin-top: 15px; width: 100%; height: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.3); }
        .size-bar-fill { height: 100%; width: 5%; background: linear-gradient(90deg, #ff8800, #ffcc00, #ffff00); box-shadow: 0 0 15px #ff8800; transition: width 0.3s ease-out; }
        .size-text { color: rgba(255, 255, 255, 0.9); font-size: 1.1rem; margin-top: 8px; font-weight: 700; }
        .sidebar { position: absolute; top: 50%; left: 30px; transform: translateY(-50%); width: 250px; display: flex; flex-direction: column; gap: 15px; }
        .target-card { background: rgba(15, 25, 50, 0.7); backdrop-filter: blur(10px); border-left: 5px solid #555; padding: 15px 20px; border-radius: 0 10px 10px 0; color: #ccc; transition: all 0.3s; box-shadow: 5px 5px 15px rgba(0,0,0,0.3); }
        .target-card.huntable { background: rgba(0, 255, 255, 0.15); border-left: 5px solid #00ffff; color: #fff; transform: scale(1.08) translateX(15px); box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .animal-name { font-weight: 800; font-size: 1.2rem; }
        .status-badge { font-size: 0.7rem; font-family: 'Orbitron', sans-serif; font-weight: 900; padding: 3px 8px; border-radius: 4px; background: #333; color: #888; }
        .target-card.huntable .status-badge { background: #00ffff; color: #000; box-shadow: 0 0 10px #00ffff; }
        .size-req { font-size: 0.85rem; opacity: 0.8; display: flex; align-items: center; gap: 8px; }
        .size-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        .target-card.huntable .size-dot { background: #00ffff; box-shadow: 0 0 8px #00ffff; }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; display: none; color: white; cursor: auto; }
        .btn { padding: 15px 60px; font-size: 1.5rem; background: transparent; color: #ff4444; border: 3px solid #ff4444; border-radius: 50px; font-family: 'Orbitron', sans-serif; font-weight: 900; cursor: pointer; transition: 0.2s; }
        .btn:hover { background: #ff4444; color: black; box-shadow: 0 0 40px #ff0000; transform: scale(1.1); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui-layer">
        <div class="top-hud">
            <h1>PROJECT: FOX</h1>
            <div class="size-bar-container"><div class="size-bar-fill" id="size-bar"></div></div>
            <div class="size-text" id="size-text">SIZE: 1.0M</div>
        </div>
        <div class="sidebar" id="target-list"></div>
    </div>
    <div id="game-over">
        <h1 style="color: #ff4444; font-size: 6rem; font-family: 'Orbitron'; text-shadow: 0 0 50px red;">DEFEATED</h1>
        <p style="color:#aaa; font-size:1.5rem; margin-bottom: 30px;">THE PREY BECAME THE PREDATOR</p>
        <button class="btn" onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <script>
        // 1. 설정
        const ANIMAL_CONFIG = {
            'player':   { color: 0xffaa33, size: 1.0, speed: 60, name: '여우' }, 
            'rabbit':   { color: 0xffffff, size: 0.5, speed: 15, name: '토끼' },
            'wolf':     { color: 0xdcdcdc, size: 1.5, speed: 20, name: '늑대' },
            'boar':     { color: 0xd2691e, size: 2.2, speed: 24, name: '멧돼지' },
            'bear':     { color: 0xcd853f, size: 3.5, speed: 14, name: '곰' },
            'elephant': { color: 0xf0f8ff, size: 8.0, speed: 20, name: '코끼리' }
        };
        const ECOSYSTEM_SETUP = [
            { type: 'rabbit', count: 35 }, { type: 'wolf', count: 18 },
            { type: 'boar', count: 14 }, { type: 'bear', count: 10 }, { type: 'elephant', count: 6 }
        ];

        // 2. 씬
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 40, 250);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 초기 카메라는 임시값 (animate에서 매 프레임 갱신됨)
        camera.position.set(0, 25, 35); 
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const hemiLight = new THREE.HemisphereLight(0x8888ff, 0x444444, 0.7);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.top = 200; dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200; dirLight.shadow.camera.right = 200;
        scene.add(dirLight);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshPhongMaterial({ color: 0x223344 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 환경
        const treeGeo = new THREE.CylinderGeometry(0.5, 0.8, 4, 6);
        const treeMat = new THREE.MeshLambertMaterial({ color: 0x554433 });
        const leafGeo = new THREE.ConeGeometry(3, 6, 8);
        const leafMat = new THREE.MeshLambertMaterial({ color: 0x335544 });
        for(let i=0; i<180; i++) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(treeGeo, treeMat);
            trunk.position.y = 2; trunk.castShadow = true; group.add(trunk);
            const leaves = new THREE.Mesh(leafGeo, leafMat);
            leaves.position.y = 5; leaves.castShadow = true; group.add(leaves);
            const s = Math.random() * 1.5 + 1;
            group.scale.set(s,s,s);
            group.position.set((Math.random()-0.5)*1000, 0, (Math.random()-0.5)*1000);
            scene.add(group);
        }

        const mushrooms = [];
        const stemGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8);
        const stemMat = new THREE.MeshLambertMaterial({color:0xffeebb});
        const capGeo = new THREE.ConeGeometry(0.8, 0.6, 8);
        const capMat = new THREE.MeshLambertMaterial({color:0xff5555});
        for(let i=0; i<80; i++) {
            const group = new THREE.Group();
            const stem = new THREE.Mesh(stemGeo, stemMat); stem.position.y = 0.4;
            const cap = new THREE.Mesh(capGeo, capMat); cap.position.y = 0.8;
            group.add(stem, cap);
            group.position.set((Math.random()-0.5)*800, 0, (Math.random()-0.5)*800);
            group.userData = { active: true, floatOffset: Math.random()*100 };
            scene.add(group); mushrooms.push(group);
        }

        // 3. 동물
        class Animal {
            constructor(type) {
                this.mesh = new THREE.Group();
                this.bodyGroup = new THREE.Group();
                this.mesh.add(this.bodyGroup);
                this.type = type;
                const config = ANIMAL_CONFIG[type];
                this.color = config.color;
                this.initialSize = config.size;
                this.currentSize = config.size;
                this.baseSpeed = config.speed;
                this.dying = false;

                const mat = new THREE.MeshLambertMaterial({ color: this.color });
                const blackMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const ivoryMat = new THREE.MeshPhongMaterial({ color: 0xfffff0 });
                const isEnemy = type !== 'player';
                const eyeColor = isEnemy ? new THREE.MeshBasicMaterial({color: 0xff0000}) : blackMat;

                if(isEnemy) {
                    this.alertIcon = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    this.alertIcon.position.y = 5 * this.initialSize; this.alertIcon.visible = false; this.mesh.add(this.alertIcon);
                }

                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 3), mat);
                // 발이 없으므로 몸통을 띄움
                body.position.y = 2; body.castShadow = true; this.bodyGroup.add(body);

                this.headGroup = new THREE.Group();
                this.headGroup.position.set(0, 2.5, 1.5); this.bodyGroup.add(this.headGroup);
                this.headGroup.add(new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 1.2), mat));

                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.8), isEnemy ? mat : whiteMat);
                snout.position.set(0, -0.2, 0.8); this.headGroup.add(snout);

                const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.1), eyeColor); eyeL.position.set(0.4, 0.1, 0.65);
                const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.1), eyeColor); eyeR.position.set(-0.4, 0.1, 0.65);
                this.headGroup.add(eyeL, eyeR);

                if(type === 'rabbit') {
                    const ear = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.2, 0.2), mat);
                    const el = ear.clone(); el.position.set(0.4, 1.0, 0); const er = ear.clone(); er.position.set(-0.4, 1.0, 0);
                    this.headGroup.add(el, er);
                } else if (type === 'elephant') {
                    const ear = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.2), mat);
                    const el = ear.clone(); el.position.set(1.0, 0, 0); el.rotation.y = -0.3; const er = ear.clone(); er.position.set(-1.0, 0, 0); er.rotation.y = 0.3;
                    this.headGroup.add(el, er);
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 1.5, 8), mat);
                    trunk.rotation.x = -Math.PI/2 + 0.5; trunk.position.set(0, -0.5, 1.5); this.headGroup.add(trunk);
                } else {
                    const ear = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.8, 4), mat);
                    const el = ear.clone(); el.position.set(0.5, 0.8, 0); el.rotation.z = -0.3; const er = ear.clone(); er.position.set(-0.5, 0.8, 0); er.rotation.z = 0.3;
                    this.headGroup.add(el, er);
                }

                // 발 제거 (유령 스타일)

                this.tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 2.5), mat);
                this.tail.position.set(0, 2.2, -1.2); this.tail.geometry.translate(0,0,-1); this.bodyGroup.add(this.tail);

                this.setSize(this.initialSize);
                if(isEnemy) this.respawn();
            }

            respawn() {
                this.dying = false; this.mesh.visible = true;
                this.mesh.scale.set(this.initialSize, this.initialSize, this.initialSize);
                const range = 800;
                this.mesh.position.set((Math.random()-0.5)*range, 0, (Math.random()-0.5)*range);
                this.mesh.rotation.y = Math.random() * Math.PI * 2; // 초기 랜덤 방향
                this.changeDirTimer = 0;
            }

            animate(time, isMoving) {
                if(this.dying) {
                    this.mesh.rotation.z += 0.1; this.mesh.position.y -= 0.1; this.mesh.scale.multiplyScalar(0.9);
                    if(this.mesh.scale.x < 0.1) this.mesh.visible = false;
                    return;
                }
                if(this.alertIcon && this.alertIcon.visible) this.alertIcon.rotation.y += 0.1;

                if(isMoving) {
                    // 유령 둥실둥실 효과 (땅에 묻히지 않게 기본 높이 1.0 + sin)
                    this.bodyGroup.position.y = 1.0 + Math.sin(time * 5) * 0.3;
                    if(this.type !== 'rabbit' && this.type !== 'bear' && this.type !== 'boar') {
                        this.tail.rotation.y = Math.sin(time * 10) * 0.3;
                    }
                } else {
                    this.bodyGroup.position.y = 1.0;
                }
            }
            setSize(s) { this.currentSize = s; this.mesh.scale.set(s, s, s); }
            grow(amount) { this.currentSize += amount; this.mesh.scale.set(this.currentSize, this.currentSize, this.currentSize); }
        }

        // 5. 실행
        const player = new Animal('player');
        scene.add(player.mesh);
        const enemies = [];

        const listDiv = document.getElementById('target-list');
        ECOSYSTEM_SETUP.forEach(setup => {
            const config = ANIMAL_CONFIG[setup.type];
            const div = document.createElement('div');
            div.className = 'target-card'; div.id = `card-${setup.type}`;
            div.innerHTML = `<div class="card-header"><span class="animal-name">${config.name}</span><span class="status-badge">DANGER</span></div><div class="size-req"><div class="size-dot"></div>REQ: ${config.size.toFixed(1)}M</div>`;
            listDiv.appendChild(div);
            for(let i=0; i<setup.count; i++) {
                const en = new Animal(setup.type);
                scene.add(en.mesh); enemies.push(en);
            }
        });

        const keys = {w:false, a:false, s:false, d:false};
        let velocityY=0, isJumping=false, rotation=0, currentSpeed=0;
        window.addEventListener('keydown', e=>{if(keys[e.key.toLowerCase()]!==undefined)keys[e.key.toLowerCase()]=true; if(e.code==='Space'&&!isJumping){isJumping=true;velocityY=1.5;}});
        window.addEventListener('keyup', e=>{if(keys[e.key.toLowerCase()]!==undefined)keys[e.key.toLowerCase()]=false;});

        const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state!=='running') audioCtx.resume();
            const osc=audioCtx.createOscillator(); const gain=audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination); const now=audioCtx.currentTime;
            if(type==='eat') { osc.frequency.setValueAtTime(600,now); osc.frequency.exponentialRampToValueAtTime(1200,now+0.1); gain.gain.setValueAtTime(0.1,now); gain.gain.linearRampToValueAtTime(0,now+0.1); }
            else if(type==='kill') { osc.type='square'; osc.frequency.setValueAtTime(100,now); osc.frequency.exponentialRampToValueAtTime(50,now+0.2); gain.gain.setValueAtTime(0.3,now); gain.gain.linearRampToValueAtTime(0,now+0.2); }
            osc.start(now); osc.stop(now+0.2);
        }

        const clock = new THREE.Clock();
        let gameOver = false;

        function animate() {
            if(gameOver) return;
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // --- 플레이어 이동 ---
            let moving = false;
            if(keys.w) { currentSpeed = player.baseSpeed; moving=true; }
            else if(keys.s) { currentSpeed = -player.baseSpeed*0.5; moving=true; }
            else { currentSpeed *= 0.8; }
            
            const rotationSpeed = 2.5;
            if(keys.a) rotation += rotationSpeed * delta;
            if(keys.d) rotation -= rotationSpeed * delta;
            
            // [중요] 절대 좌표계 사용 (Sin/Cos) - 이렇게 하면 방향이 꼬이지 않음
            // rotation 0 = +Z 방향을 정면으로 봄
            player.mesh.rotation.y = rotation;
            player.mesh.position.x += Math.sin(rotation) * currentSpeed * delta;
            player.mesh.position.z += Math.cos(rotation) * currentSpeed * delta;
            
            if(isJumping) { 
                player.mesh.position.y += velocityY; velocityY -= 4.0 * delta; 
                if(player.mesh.position.y <= 0) { player.mesh.position.y = 0; isJumping=false; }
            }
            player.animate(time, moving);

            // [중요] 카메라 위치 고정 (플레이어 등 뒤)
            // 플레이어 위치 - (바라보는 방향 벡터 * 거리) = 등 뒤
            const fixDist = 35;  
            const fixHeight = 25;
            const targetX = player.mesh.position.x - Math.sin(rotation) * fixDist;
            const targetZ = player.mesh.position.z - Math.cos(rotation) * fixDist;
            
            camera.position.lerp(new THREE.Vector3(targetX, player.mesh.position.y + fixHeight, targetZ), 0.1);
            camera.lookAt(player.mesh.position.x, player.mesh.position.y + (player.currentSize * 2), player.mesh.position.z);

            // --- 적 AI ---
            enemies.forEach(enemy => {
                if(enemy.dying) { 
                    enemy.animate(time, false); 
                    if(!enemy.mesh.visible && Math.random() < 0.01) enemy.respawn(); 
                    return; 
                }

                const dist = player.mesh.position.distanceTo(enemy.mesh.position);
                let isMoving = true;

                // 1. 추격 (나보다 큰 놈)
                if (enemy.currentSize > player.currentSize && dist < 160) {
                    enemy.alertIcon.visible = true;
                    // 타겟 방향 벡터 (플레이어 - 적)
                    const dx = player.mesh.position.x - enemy.mesh.position.x;
                    const dz = player.mesh.position.z - enemy.mesh.position.z;
                    // LookAt을 위해 타겟 위치 설정
                    enemy.mesh.lookAt(player.mesh.position);
                    // 전진 (방향 벡터 정규화 후 속도 곱함)
                    const moveDir = new THREE.Vector3(dx, 0, dz).normalize();
                    enemy.mesh.position.add(moveDir.multiplyScalar(enemy.baseSpeed * 1.3 * delta));
                } 
                // 2. 도망 (나보다 작은 놈)
                else if (enemy.currentSize <= player.currentSize && dist < 120) {
                    // 도망 방향 벡터 (적 - 플레이어) = 나로부터 멀어지는 방향
                    const dx = enemy.mesh.position.x - player.mesh.position.x;
                    const dz = enemy.mesh.position.z - player.mesh.position.z;
                    // 적이 가야할 목표 지점 (현재 위치 + 도망 방향)을 바라보게 함
                    const fleeTarget = new THREE.Vector3(enemy.mesh.position.x + dx, enemy.mesh.position.y, enemy.mesh.position.z + dz);
                    enemy.mesh.lookAt(fleeTarget);
                    // 전진
                    const moveDir = new THREE.Vector3(dx, 0, dz).normalize();
                    enemy.mesh.position.add(moveDir.multiplyScalar(enemy.baseSpeed * 1.5 * delta));
                } 
                // 3. 배회
                else {
                    enemy.alertIcon.visible = false;
                    enemy.changeDirTimer -= delta;
                    // 방향 전환
                    if(enemy.changeDirTimer < 0 || !enemy.wanderDir) {
                        enemy.changeDirTimer = Math.random() * 3 + 2;
                        // 랜덤 방향 벡터 생성
                        enemy.wanderDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                    }
                    // 해당 방향으로 이동
                    enemy.mesh.position.add(enemy.wanderDir.clone().multiplyScalar(enemy.baseSpeed * delta));
                    // 이동하는 방향 바라보기 (현재위치 + 방향)
                    const lookTarget = enemy.mesh.position.clone().add(enemy.wanderDir);
                    enemy.mesh.lookAt(lookTarget);
                }
                
                enemy.animate(time, isMoving);

                // 충돌 처리
                const collisionDist = 2.0 * ((player.currentSize + enemy.currentSize) / 2);
                if(dist < collisionDist) {
                    if (player.currentSize >= enemy.currentSize) {
                        enemy.dying = true; enemy.alertIcon.visible = false; playSound('kill');
                        player.grow(enemy.initialSize * 0.1); updateStatus();
                    } else {
                        gameOver = true; document.getElementById('game-over').style.display = 'flex';
                        document.body.style.cursor = 'auto';
                    }
                }
            });

            mushrooms.forEach(m => {
                if(!m.userData.active) return;
                m.position.y = 0.5 + Math.sin(time*3 + m.userData.floatOffset)*0.2; m.rotation.y += 0.02;
                if(player.mesh.position.distanceTo(m.position) < 3.0 * player.currentSize) {
                    m.userData.active = false; m.visible = false;
                    player.grow(0.1); playSound('eat'); updateStatus();
                    setTimeout(() => { m.position.set((Math.random()-0.5)*800, 0, (Math.random()-0.5)*800); m.visible = true; m.userData.active = true; }, 3000);
                }
            });

            renderer.render(scene, camera);
        }

        function updateStatus() {
            document.getElementById('size-text').innerText = `SIZE: ${player.currentSize.toFixed(1)}M`;
            let percentage = (player.currentSize / 8.0) * 100; if(percentage > 100) percentage = 100;
            document.getElementById('size-bar').style.width = `${percentage}%`;
            
            ECOSYSTEM_SETUP.forEach(setup => {
                const config = ANIMAL_CONFIG[setup.type];
                const card = document.getElementById(`card-${setup.type}`);
                if (player.currentSize >= config.size && !card.classList.contains('huntable')) {
                    card.classList.add('huntable');
                    card.querySelector('.status-badge').innerText = "HUNT";
                }
            });
        }

        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>